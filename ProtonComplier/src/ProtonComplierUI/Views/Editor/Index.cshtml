@model EditorViewModel

@{
    ViewData["Title"] = "Editor";
}

@section EditorBar {
    @await Html.PartialAsync("EditorBar")
}

@if (TempData["ErrorMessage"] != null)
{
    <div id="tempErrorMessage" class="error-banner">
        @TempData["ErrorMessage"]
    </div>
}

<section class="DocuBodyEditor">
    <!-- Main content with Monaco Editor Panels -->
    <div class="wrapper">
        <div id="editor-container" class="box">
            <div id="editor-inner"></div>
        </div>
        <div class="handler"></div>
        <div class="right-container box">
            <!-- Right container with two inner rows -->
            <div id="right-editor-container" class="row">
                <div id="right-editor-inner"></div>
            </div>
            <div id="consolePanel" class="alert-secondary row">
                <span id="compilerOutput">
                    @if (!string.IsNullOrEmpty(Model.ConsoleMessage))
                    {
                        <span>@Model.ConsoleMessage </span>
                        <br />
                    }
                    <span id="blinkingArrow">ProtonCompiler >> </span>
                </span>
            </div>
        </div>
    </div>
</section>

<script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/7.0.5/signalr.min.js"></script>
<script>
    let outputString = ""; // Declare this outside the handler to accumulate messages

    const connection = new signalR.HubConnectionBuilder()
        .withUrl("/compilerhub")
        .build();

    connection.on("ReceiveOutput", function (message) {
        // outputString += message + "\n";
        // console.log("Received:", outputString);

        // Accumulate output
        window.outputText = (window.outputText || "") + message + "\n";

        // Update Monaco editor
        if (typeof rightEditor !== 'undefined') {
            rightEditor.setValue(window.outputText);
        }

        // Update the HTML console panel
        const output = document.getElementById("compilerOutput");
        const blinkingArrow = document.getElementById("blinkingArrow");

        if (output && blinkingArrow) {
            const formattedMessage = document.createElement("span");
            formattedMessage.textContent = message;

            output.insertBefore(formattedMessage, blinkingArrow);
            output.insertBefore(document.createElement("br"), blinkingArrow);

            // Scroll the parent container to the bottom
            output.parentElement.scrollTop = output.parentElement.scrollHeight;
        }
    });

    let connectionId = null;

    connection.start()
        .then(() => {
            return connection.invoke("GetConnectionId");
        })
        .then(id => {
            connectionId = id;
            console.log("Connected with ID:", connectionId);
        })
        .catch(err => console.error(err.toString()));

    document.getElementById("compileAndRunButton").addEventListener("click", function () {
        document.getElementById("InputText").value = editor.getValue();
        const code = document.getElementById("InputText").value;

        // Clear previous output
        window.outputText = "";
        if (typeof rightEditor !== 'undefined') {
            rightEditor.setValue(""); // Clear Monaco output
        }

        // Reset HTML console output with correct label
        const output = document.getElementById("compilerOutput");
        if (output) {
            output.innerHTML = '<span id="blinkingArrow">ProtonCompiler &gt;&gt; </span>';
        }

        fetch("/Editor/CompileAndRun", {
            method: "POST",
            body: new URLSearchParams({ code: code, connectionId: connectionId }),
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' }
        });
    });

</script>

<script>
    // Serialize values from Razor into global JS variables
    window.editorInputText = @Html.Raw(Json.Serialize(Model.InputText));
    window.outputText = @Html.Raw(Json.Serialize(Model.OutputText ?? "No output"));
</script>
